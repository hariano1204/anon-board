/*
 *
 *
 *
 *
 *
 *       DO NOT EDIT THIS FILE
 *       For FCC testing purposes!
 *
 *
 *
 *
 *
 */

function objParser(str, init) {
  // finds objects, arrays, strings, and function arguments
  // between parens, because they may contain ','
  let openSym = ['[', '{', '"', "'", '('];
  let closeSym = [']', '}', '"', "'", ')'];
  let type;
  let i;
  let open;
  let close;
  let count;
  let result = [];
  let buffer = [];
  let inQuote = false;

  for (i = (init || 0); i < str.length; i++) {
    open = openSym.indexOf(str[i]);
    close = closeSym.indexOf(str[i]);

    if (open >= 0) {
      if (open === 3 && inQuote) {
        inQuote = false;
      } else if (open === 2 && inQuote) {
        inQuote = false;
      } else {
        type = open;
        count = 1;
        for (let k = i + 1; k < str.length; k++) {
          if (str[k] === openSym[type]) {
            count++;
          } else if (str[k] === closeSym[type]) {
            count--;
            if (count === 0) {
              result.push(str.slice(i, k + 1));
              buffer.push(i, k + 1);
              i = k;
              break;
            }
          }
        }
      }
    } else if (close >= 0) {
      return result;
    }
  }
  return result;
}

function assertionAnalyser(body) {
  // already filtered in the test runner
  // * replace assertions bodies with asterisks
  // * replace the test function name
  let assertions = body.match(/assert\.(.+?\(.+?\))/g);
  if (assertions) {
    return assertions.map(function (a) {
      let args = a.match(/\((.+)\)/)[1];
      let parens = objParser(args);
      return {
        text: a.replace(/\(.+\)/, '()'),
        args: parens.map(function (p) {
          return p;
        })
      };
    });
  } else {
    return [];
  }
}

module.exports = assertionAnalyser;
